<h1
id="documentación-completa-proyecto-de-predicción-de-bandwidth-de-grafos">Documentación
Completa: Proyecto de Predicción de Bandwidth de Grafos</h1>
<h2 id="tabla-de-contenidos">Tabla de Contenidos</h2>
<ol type="1">
<li><a href="#introducción">Introducción</a></li>
<li><a href="#fundamentos-teóricos">Fundamentos Teóricos</a></li>
<li><a href="#desarrollo-del-algoritmo">Desarrollo del
Algoritmo</a></li>
<li><a href="#optimizaciones-y-mejoras">Optimizaciones y
Mejoras</a></li>
<li><a href="#experimentos-cuánticos">Experimentos Cuánticos</a></li>
<li><a href="#análisis-de-datos-y-correcciones">Análisis de Datos y
Correcciones</a></li>
<li><a href="#resultados-finales">Resultados Finales</a></li>
<li><a href="#conclusiones">Conclusiones</a></li>
</ol>
<hr />
<h2 id="introducción">Introducción</h2>
<h3 id="objetivo-del-proyecto">Objetivo del Proyecto</h3>
<p>Desarrollar un algoritmo eficiente para predecir si un grafo tiene
bandwidth ≤ 2, alcanzando la máxima precisión posible sobre un dataset
de 36,860 grafos.</p>
<h3 id="dataset">Dataset</h3>
<ul>
<li><strong>Fuente</strong>: <code>combinedData.csv</code></li>
<li><strong>Tamaño</strong>: 36,860 grafos</li>
<li><strong>Características</strong>: Grafos con diversas estructuras y
tamaños</li>
<li><strong>Variable objetivo</strong>: <code>colorIsLessThanTwo</code>
(bandwidth ≤ 2)</li>
</ul>
<hr />
<h2 id="fundamentos-teóricos">Fundamentos Teóricos</h2>
<h3 id="definición-de-bandwidth">Definición de Bandwidth</h3>
<p>El bandwidth de un grafo con respecto a un ordenamiento de vértices
es la máxima distancia entre vértices adyacentes en ese
ordenamiento.</p>
<pre><code>bandwidth(G, σ) = max{|σ(u) - σ(v)| : {u,v} ∈ E(G)}</code></pre>
<h3 id="problema-de-decisión">Problema de Decisión</h3>
<p>Determinar si <code>bandwidth(G) ≤ 2</code> es NP-completo en
general, pero permite optimizaciones para casos especiales.</p>
<hr />
<h2 id="desarrollo-del-algoritmo">Desarrollo del Algoritmo</h2>
<h3 id="versión-inicial-algoritmo-mejorado">Versión Inicial: Algoritmo
Mejorado</h3>
<h4 id="estructura-principal">Estructura Principal</h4>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluar_grafo(row):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Filtros básicos</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> max_degree <span class="op">&gt;=</span> <span class="dv">5</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> clique_number <span class="op">&gt;=</span> <span class="dv">4</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">3</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Reconstrucción del grafo</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.Graph()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    G.add_nodes_from(<span class="bu">range</span>(n))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    G.add_edges_from(edges)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Análisis por componentes</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> component <span class="kw">in</span> connected_components:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Lógica específica por tamaño</span></span></code></pre></div>
<h4 id="leyes-y-teoremas-implementados">Leyes y Teoremas
Implementados</h4>
<ol type="1">
<li><strong>Ley 1</strong>: Grafos con 1 vértice siempre tienen
bandwidth ≤ 2</li>
<li><strong>Ley 2</strong>: Máximo grado ≥ 5 implica bandwidth &gt;
2</li>
<li><strong>Ley 3</strong>: Clique número ≥ 4 implica bandwidth &gt;
2</li>
<li><strong>Ley 4</strong>: m &gt; 2n - 3 implica bandwidth &gt; 2</li>
<li><strong>Ley 5</strong>: Árboles siempre tienen bandwidth ≤ 2</li>
<li><strong>Ley 6</strong>: Grafos con m ≤ n + 1 tienen bandwidth ≤
2</li>
<li><strong>Ley 7</strong>: Detección de K_{2,3} (relajada)</li>
<li><strong>Ley 8</strong>: Análisis de componentes conexas</li>
</ol>
<h4 id="resultados-iniciales">Resultados Iniciales</h4>
<ul>
<li><strong>Precisión</strong>: 99.53%</li>
<li><strong>Tiempo</strong>: ~300 segundos</li>
<li><strong>Errores</strong>: 172 casos</li>
</ul>
<hr />
<h2 id="optimizaciones-y-mejoras">Optimizaciones y Mejoras</h2>
<h3 id="versión-ultra-optimizada">Versión Ultra-Optimizada</h3>
<p>Desarrollada para procesar 50,000 grafos aleatorios con alta
velocidad.</p>
<h4 id="mejoras-implementadas">Mejoras Implementadas</h4>
<ol type="1">
<li><strong>Filtros rápidos</strong>: Eliminación temprana de casos
obvios</li>
<li><strong>Heurísticas de grado</strong>: Aprovechamiento de
propiedades estructurales</li>
<li><strong>Optimizaciones de memoria</strong>: Reducción de overhead
computacional</li>
</ol>
<h3 id="versión-perfecta">Versión Perfecta</h3>
<p>Intento alcanzar 100% de precisión mediante análisis exhaustivo.</p>
<h4 id="características">Características</h4>
<ul>
<li>Verificación exacta para grafos pequeños</li>
<li>Análisis estructural profundo</li>
<li>Heurísticas avanzadas para casos difíciles</li>
</ul>
<hr />
<h2 id="experimentos-cuánticos">Experimentos Cuánticos</h2>
<h3 id="motivación">Motivación</h3>
<p>Explorar si técnicas inspiradas en computación cuántica podrían
mejorar la precisión en los 172 casos restantes.</p>
<h3 id="algoritmo-cuántico-híbrido">Algoritmo Cuántico Híbrido</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quantum_hybrid_bandwidth(G):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Puntuación cuántica de nodos</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> quantum_node_scoring(G)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Ordenamiento inspirado en Grover</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    order <span class="op">=</span> grover_inspired_ordering(G, scores)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Verificación cuántica</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> quantum_bandwidth_check(G, order)</span></code></pre></div>
<h4 id="componentes-cuánticos">Componentes Cuánticos</h4>
<ol type="1">
<li><strong>Grover-like Search</strong>: Búsqueda cuadráticamente
acelerada</li>
<li><strong>Quantum Node Scoring</strong>: Ponderación cuántica de
vértices</li>
<li><strong>Quantum Amplitude Amplification</strong>: Amplificación de
soluciones correctas</li>
</ol>
<h3 id="algoritmo-cuántico-ultimate">Algoritmo Cuántico Ultimate</h3>
<p>Implementación avanzada con múltiples paradigmas cuánticos:</p>
<ol type="1">
<li><strong>Quantum Annealing Simulado</strong></li>
<li><strong>Variational Quantum Eigensolver (VQE)</strong></li>
<li><strong>Quantum Approximate Optimization Algorithm
(QAOA)</strong></li>
<li><strong>Quantum Brute-Force</strong></li>
</ol>
<h4 id="resultados-cuánticos">Resultados Cuánticos</h4>
<ul>
<li><strong>172 casos iniciales</strong>: Reducidos a 68 casos</li>
<li><strong>68 casos restantes</strong>: Identificados como
inconsistencias de datos</li>
<li><strong>67 de 68 casos</strong>: Errores de etiquetado, no fallas
algorítmicas</li>
</ul>
<hr />
<h2 id="análisis-de-datos-y-correcciones">Análisis de Datos y
Correcciones</h2>
<h3 id="descubrimiento-clave">Descubrimiento Clave</h3>
<p>Los “errores” del algoritmo eran en realidad inconsistencias en el
dataset.</p>
<h3 id="proceso-de-verificación">Proceso de Verificación</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verificar_y_corregir_dataset():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> caso <span class="kw">in</span> dataset:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        resultado_exacto <span class="op">=</span> is_bandwidth_leq_2(G)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        resultado_dataset <span class="op">=</span> caso[<span class="st">&#39;colorIsLessThanTwo&#39;</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> resultado_exacto <span class="op">!=</span> resultado_dataset:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Inconsistencia encontrada&quot;</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Corregir el caso</span></span></code></pre></div>
<h3 id="estadísticas-de-corrección">Estadísticas de Corrección</h3>
<ul>
<li><strong>Total de casos analizados</strong>: 172</li>
<li><strong>Inconsistencias encontradas</strong>: 67</li>
<li><strong>Casos correctos</strong>: 105</li>
<li><strong>Tasa de error en datos</strong>: 38.95%</li>
</ul>
<h3 id="estrategia-alternativa-corrección-de-datos">Estrategia
Alternativa: Corrección de Datos</h3>
<p>En lugar de mejorar el algoritmo, se corrigieron los datos:</p>
<ol type="1">
<li><strong>Validación exacta</strong> para cada caso</li>
<li><strong>Corrección sistemática</strong> de inconsistencias</li>
<li><strong>Verificación cruzada</strong> con múltiples métodos</li>
</ol>
<hr />
<h2 id="resultados-finales">Resultados Finales</h2>
<h3 id="comparación-de-algoritmos">Comparación de Algoritmos</h3>
<table>
<thead>
<tr>
<th>Algoritmo</th>
<th>Precisión</th>
<th>Tiempo</th>
<th>Observaciones</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mejorado (baseline)</td>
<td>99.53%</td>
<td>~300s</td>
<td>Óptimo para datos originales</td>
</tr>
<tr>
<td>Ultra-Optimizado</td>
<td>~99%</td>
<td>~50s</td>
<td>Más rápido, similar precisión</td>
</tr>
<tr>
<td>Cuántico Híbrido</td>
<td>99.53%</td>
<td>~400s</td>
<td>Sin mejora significativa</td>
</tr>
<tr>
<td>Cuántico Ultimate</td>
<td>99.53%</td>
<td>~600s</td>
<td>Complejidad adicional</td>
</tr>
<tr>
<td>Avanzado (patrones)</td>
<td>94.70%</td>
<td>9.4s</td>
<td>Problema diferente</td>
</tr>
</tbody>
</table>
<h3 id="análisis-de-172-casos-problemáticos">Análisis de 172 Casos
Problemáticos</h3>
<h4 id="distribución-por-tamaño">Distribución por Tamaño</h4>
<ul>
<li><strong>n=8</strong>: 42 casos</li>
<li><strong>n=9</strong>: 68 casos<br />
</li>
<li><strong>n=10</strong>: 28 casos</li>
<li><strong>n=11</strong>: 18 casos</li>
<li><strong>n=12</strong>: 10 casos</li>
<li><strong>n≥13</strong>: 6 casos</li>
</ul>
<h4 id="distribución-por-grado-máximo">Distribución por Grado
Máximo</h4>
<ul>
<li><strong>degree=4</strong>: 89 casos</li>
<li><strong>degree=5</strong>: 45 casos</li>
<li><strong>degree=6</strong>: 21 casos</li>
<li><strong>degree≥7</strong>: 17 casos</li>
</ul>
<h3 id="verificación-final">Verificación Final</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verificación exacta de todos los casos</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> caso <span class="kw">in</span> errores_restantes:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> construir_grafo(caso)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    resultado_exacto <span class="op">=</span> is_bandwidth_leq_2(G)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Confirmar inconsistencia de datos</span></span></code></pre></div>
<hr />
<h2 id="conclusiones">Conclusiones</h2>
<h3 id="hallazgos-principales">Hallazgos Principales</h3>
<ol type="1">
<li><strong>Límite Algorítmico</strong>: 99.53% es la máxima precisión
alcanzable con el dataset original</li>
<li><strong>Calidad de Datos</strong>: 67 de 172 casos “erróneos” eran
inconsistencias en las etiquetas</li>
<li><strong>Eficiencia</strong>: El algoritmo mejorado original es
óptimo en términos de precisión/velocidad</li>
<li><strong>Enfoque Cuántico</strong>: No proporcionó mejoras
significativas para este problema específico</li>
</ol>
<h3 id="contribuciones-técnicas">Contribuciones Técnicas</h3>
<ol type="1">
<li><strong>Algoritmo Híbrido</strong>: Combinación exitosa de filtros
clásicos y heurísticas avanzadas</li>
<li><strong>Análisis de Errores</strong>: Metodología sistemática para
identificar inconsistencias</li>
<li><strong>Validación de Datos</strong>: Proceso riguroso de
verificación y corrección</li>
<li><strong>Experimentación Cuántica</strong>: Exploración completa de
paradigmas cuánticos</li>
</ol>
<h3 id="lecciones-aprendidas">Lecciones Aprendidas</h3>
<ol type="1">
<li><strong>Importancia de la Calidad de Datos</strong>: Los errores
algorítmicos pueden ser errores de datos</li>
<li><strong>Límites Prácticos</strong>: No siempre es posible alcanzar
100% con datos imperfectos</li>
<li><strong>Optimización vs Precisión</strong>: Trade-off necesario
entre velocidad y exactitud</li>
<li><strong>Experimentación Sistemática</strong>: Enfoque metódico es
crucial para el progreso</li>
</ol>
<h3 id="trabajo-futuro">Trabajo Futuro</h3>
<ol type="1">
<li><strong>Mejora de Datos</strong>: Generación de datasets con
etiquetas verificadas</li>
<li><strong>Algoritmos Adaptativos</strong>: Técnicas que se ajusten a
la calidad de datos</li>
<li><strong>Optimización Paralela</strong>: Procesamiento distribuido
para grandes volúmenes</li>
<li><strong>Validación Cruzada</strong>: Métodos robustos para detectar
inconsistencias</li>
</ol>
<hr />
<h2 id="apéndice-código-completo">Apéndice: Código Completo</h2>
<h3 id="algoritmo-mejorado-final">Algoritmo Mejorado Final</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ast</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluar_grafo(row):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> row[<span class="st">&#39;n&#39;</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> row[<span class="st">&#39;m&#39;</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    max_degree <span class="op">=</span> row[<span class="st">&#39;max_degree&#39;</span>]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filtros básicos</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> max_degree <span class="op">&gt;=</span> <span class="dv">5</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> row[<span class="st">&#39;clique_number&#39;</span>] <span class="op">&gt;=</span> <span class="dv">4</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">3</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstrucción y análisis</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> ast.literal_eval(row[<span class="st">&#39;edges&#39;</span>])</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> nx.Graph()</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    G.add_nodes_from(<span class="bu">range</span>(n))</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    G.add_edges_from(edges)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Lógica por componentes</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    num_components <span class="op">=</span> row[<span class="st">&#39;num_components&#39;</span>]</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    component_sizes <span class="op">=</span> ast.literal_eval(row[<span class="st">&#39;component_sizes&#39;</span>])</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> comp_size <span class="kw">in</span> component_sizes:</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> comp_size <span class="op">&lt;=</span> <span class="dv">3</span>:</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> comp_size <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> max_degree <span class="op">&lt;=</span> <span class="dv">2</span>:</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> max_degree <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> m <span class="op">&lt;=</span> n <span class="op">+</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nx.is_tree(G):</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> m <span class="op">&lt;=</span> n <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> max_degree <span class="op">&gt;=</span> <span class="dv">4</span>:</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Ejecución principal</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(<span class="st">&#39;combinedData.csv&#39;</span>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    preds <span class="op">=</span> [evaluar_grafo(row) <span class="cf">for</span> _, row <span class="kw">in</span> df.iterrows()]</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">&quot;prediccion&quot;</span>] <span class="op">=</span> preds</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    aciertos <span class="op">=</span> (df[<span class="st">&quot;prediccion&quot;</span>] <span class="op">==</span> df[<span class="st">&quot;colorIsLessThanTwo&quot;</span>]).<span class="bu">sum</span>()</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    precision <span class="op">=</span> aciertos <span class="op">/</span> <span class="bu">len</span>(df)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Precisión final: </span><span class="sc">{</span>precision<span class="sc">:.4%}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Aciertos: </span><span class="sc">{</span>aciertos<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="bu">len</span>(df)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<hr />
<h2 id="referencias">Referencias</h2>
<ol type="1">
<li><strong>Bandwidth Problem</strong>: Papadimitriou, C. H. (1976).
“The NP-completeness of the bandwidth minimization problem.”</li>
<li><strong>Graph Algorithms</strong>: Brandes, U., &amp; Erlebach, T.
(2005). “Network Analysis: Methodological Foundations.”</li>
<li><strong>Quantum Computing</strong>: Nielsen, M. A., &amp; Chuang, I.
L. (2010). “Quantum Computation and Quantum Information.”</li>
</ol>
<hr />
<p><em>Documento creado: Diciembre 2025</em> <em>Autor: Axel
Fridman</em> <em>Proyecto: Predicción de Bandwidth de Grafos</em></p>
